# === EffectParser.py ===
# Parses AST into behavior trees and static abilities

"""EffectParser module.

This module converts the simplified AST generated by
``OracleASTCompiler`` into a structured intermediate representation
that more closely mirrors Magic's Comprehensive Rules terminology.
It does **not** modify any game state and is purely a semantic
translator.
"""

from typing import Any, Dict, List

from .EffectRegistry import STANDARD_EFFECTS
from .Tokenizer import Tokenizer, TokenType
from .ClauseParser import _parse_trigger_tokens, _parse_condition_tokens

class EffectParser:
    """Translate AST nodes into rule-tagged effect dictionaries."""

    def __init__(self) -> None:
        self.tokenizer = Tokenizer()

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------
    def parse_ast(self, ast_node: Any, card: Any | None = None) -> Dict[str, Any]:
        """Recursively convert ``ast_node`` into a structured effect tree."""

        if isinstance(ast_node, list):
            sequence = [self.parse_ast(n, card=card) for n in ast_node]
            if len(sequence) == 1:
                return sequence[0]
            return {"type": "sequence", "effects": sequence, "cr_tag": "608.1"}

        if isinstance(ast_node, dict):
            node_type = ast_node.get("type", "effect")

            if node_type == "modal":
                return {
                    "type": "modal",
                    "choose": 1,
                    "options": [self.parse_ast(o, card=card) for o in ast_node.get("options", [])],
                    "cr_tag": "608.4",
                }

            if node_type == "conditional":
                return {
                    "type": "conditional",
                    "condition": ast_node.get("condition", ""),
                    "then": self.parse_ast(ast_node.get("then", []), card=card),
                    "else": self.parse_ast(ast_node.get("else", []), card=card) if "else" in ast_node else None,
                    "cr_tag": "609.3",
                }

            if node_type == "repeat":
                inner = self.parse_ast(ast_node.get("children", []), card=card)
                inner["repeat"] = True
                return inner

            if node_type == "effect":
                return self._parse_effect_clause(ast_node.get("content", ""))

        return {"action": {"action": "unparsed_effect", "raw_node": str(ast_node)}, "cr_tag": "608.1"}

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------
    def _parse_effect_clause(self, text: str) -> Dict[str, Any]:
        """Parse a single effect clause into trigger/condition/action nodes."""

        tokens = self.tokenizer.tokenize(text)
        trigger = None
        condition = None

        i = 0
        if i < len(tokens) and tokens[i].type == TokenType.TRIGGER_WORD:
            trig, i = _parse_trigger_tokens(tokens, i)
            trigger = trig.get("trigger")
            if isinstance(trigger, dict):
                trigger["cr_tag"] = "603.1"

        if i < len(tokens) and tokens[i].type == TokenType.CONDITION_WORD:
            condition, i = _parse_condition_tokens(tokens, i)
            if isinstance(condition, dict):
                condition["cr_tag"] = "603.4"

        action_tokens = tokens[i:]
        action_text = " ".join(t.text for t in action_tokens)
        action = self._parse_effect(action_tokens, action_text)

        return {
            "trigger": trigger,
            "condition": condition,
            "action": action,
        }

    def _parse_effect(self, tokens: List[Any], raw_text: str) -> Dict[str, Any]:
        """Interpret ``tokens`` describing the effect's action."""

        joined = raw_text.lower()
        template: Dict[str, Any] | None = None
        for entry in STANDARD_EFFECTS.values():
            if any(phrase in joined for phrase in entry.get("phrases", [])):
                template = entry.get("parse")(joined)
                break

        action_index = next((i for i, t in enumerate(tokens) if t.type == TokenType.ACTION_WORD), None)

        subject_tokens = tokens[:action_index] if action_index is not None else []
        object_tokens = tokens[action_index + 1 :] if action_index is not None else tokens

        subject = " ".join(t.text for t in subject_tokens) or None
        obj = " ".join(t.text for t in object_tokens) or None
        action_word = tokens[action_index].text if action_index is not None else None

        effect_type = action_word or "unparsed_effect"
        if isinstance(template, dict):
            effect_type = template.get("action", effect_type)

        effect: Dict[str, Any] = {
            "effect_type": effect_type,
            "subject": subject,
            "object": obj,
            "raw_text": joined,
            "cr_tag": "608.1",
        }

        if template:
            if isinstance(template, dict):
                effect.update(template)
            else:
                effect["details"] = template

        return effect
